{"ast":null,"code":"import { keyframes } from '../generators/keyframes.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { frameloopDriver } from './driver-frameloop.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nconst types = {\n  decay: inertia,\n  inertia,\n  tween: keyframes,\n  keyframes: keyframes,\n  spring\n};\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\nfunction calculateDuration(generator) {\n  let duration = 0;\n  const timeStep = 50;\n  let state = generator.next(duration);\n  while (!state.done && duration < maxDuration) {\n    duration += timeStep;\n    state = generator.next(duration);\n  }\n  return duration;\n}\nfunction animateValue(_ref) {\n  let {\n    autoplay = true,\n    delay = 0,\n    driver = frameloopDriver,\n    keyframes: keyframes$1,\n    type = \"keyframes\",\n    repeat = 0,\n    repeatDelay = 0,\n    repeatType = \"loop\",\n    onPlay,\n    onStop,\n    onComplete,\n    onUpdate,\n    ...options\n  } = _ref;\n  let resolveFinishedPromise;\n  let currentFinishedPromise;\n  /**\n   * Create a new finished Promise every time we enter the\n   * finished state and resolve the old Promise. This is\n   * WAAPI-compatible behaviour.\n   */\n  const updateFinishedPromise = () => {\n    currentFinishedPromise = new Promise(resolve => {\n      resolveFinishedPromise = resolve;\n    });\n  };\n  // Create the first finished promise\n  updateFinishedPromise();\n  let animationDriver;\n  const generatorFactory = types[type] || keyframes;\n  /**\n   * If this isn't the keyframes generator and we've been provided\n   * strings as keyframes, we need to interpolate these.\n   * TODO: Support velocity for units and complex value types/\n   */\n  let mapNumbersToKeyframes;\n  if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n    mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n      clamp: false\n    });\n    keyframes$1 = [0, 100];\n  }\n  const generator = generatorFactory({\n    ...options,\n    keyframes: keyframes$1\n  });\n  let mirroredGenerator;\n  if (repeatType === \"mirror\") {\n    mirroredGenerator = generatorFactory({\n      ...options,\n      keyframes: [...keyframes$1].reverse(),\n      velocity: -(options.velocity || 0)\n    });\n  }\n  let playState = \"idle\";\n  let holdTime = null;\n  let startTime = null;\n  /**\n   * If duration is undefined and we have repeat options,\n   * we need to calculate a duration from the generator.\n   *\n   * We set it to the generator itself to cache the duration.\n   * Any timeline resolver will need to have already precalculated\n   * the duration by this step.\n   */\n  if (generator.calculatedDuration === null && repeat) {\n    generator.calculatedDuration = calculateDuration(generator);\n  }\n  const {\n    calculatedDuration\n  } = generator;\n  let resolvedDuration = Infinity;\n  let totalDuration = Infinity;\n  if (calculatedDuration) {\n    resolvedDuration = calculatedDuration + repeatDelay;\n    totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n  }\n  let time = 0;\n  const tick = timestamp => {\n    if (startTime === null) return;\n    if (holdTime !== null) {\n      time = holdTime;\n    } else {\n      time = timestamp - startTime;\n    }\n    // Rebase on delay\n    time = Math.max(time - delay, 0);\n    /**\n     * If this animation has finished, set the current time\n     * to the total duration.\n     */\n    if (playState === \"finished\" && holdTime === null) {\n      time = totalDuration;\n    }\n    let elapsed = time;\n    let frameGenerator = generator;\n    if (repeat) {\n      /**\n       * Get the current progress (0-1) of the animation. If t is >\n       * than duration we'll get values like 2.5 (midway through the\n       * third iteration)\n       */\n      const progress = time / resolvedDuration;\n      /**\n       * Get the current iteration (0 indexed). For instance the floor of\n       * 2.5 is 2.\n       */\n      let currentIteration = Math.floor(progress);\n      /**\n       * Get the current progress of the iteration by taking the remainder\n       * so 2.5 is 0.5 through iteration 2\n       */\n      let iterationProgress = progress % 1.0;\n      /**\n       * If iteration progress is 1 we count that as the end\n       * of the previous iteration.\n       */\n      if (!iterationProgress && progress >= 1) {\n        iterationProgress = 1;\n      }\n      iterationProgress === 1 && currentIteration--;\n      /**\n       * Reverse progress if we're not running in \"normal\" direction\n       */\n      const iterationIsOdd = currentIteration % 2;\n      if (iterationIsOdd) {\n        if (repeatType === \"reverse\") {\n          iterationProgress = 1 - iterationProgress;\n          if (repeatDelay) {\n            iterationProgress -= repeatDelay / resolvedDuration;\n          }\n        } else if (repeatType === \"mirror\") {\n          frameGenerator = mirroredGenerator;\n        }\n      }\n      const p = time >= totalDuration ? repeatType === \"reverse\" && iterationIsOdd ? 0 : 1 : clamp(0, 1, iterationProgress);\n      elapsed = p * resolvedDuration;\n    }\n    const state = frameGenerator.next(elapsed);\n    let {\n      value,\n      done\n    } = state;\n    if (onUpdate) {\n      onUpdate(mapNumbersToKeyframes ? mapNumbersToKeyframes(value) : value);\n    }\n    if (calculatedDuration !== null) {\n      done = time >= totalDuration;\n    }\n    const isAnimationFinished = holdTime === null && (playState === \"finished\" || playState === \"running\" && done);\n    if (isAnimationFinished) {\n      finish();\n    }\n    return state;\n  };\n  const finish = () => {\n    animationDriver && animationDriver.stop();\n    playState = \"finished\";\n    onComplete && onComplete();\n    resolveFinishedPromise();\n    updateFinishedPromise();\n  };\n  const play = () => {\n    if (!animationDriver) animationDriver = driver(tick);\n    const now = animationDriver.now();\n    onPlay && onPlay();\n    playState = \"running\";\n    if (holdTime !== null) {\n      startTime = now - holdTime;\n    } else if (!startTime) {\n      // TODO When implementing play/pause, check WAAPI\n      // logic around finished animations\n      startTime = now;\n    }\n    holdTime = null;\n    animationDriver.start();\n  };\n  if (autoplay) {\n    play();\n  }\n  const controls = {\n    then(resolve, reject) {\n      return currentFinishedPromise.then(resolve, reject);\n    },\n    get time() {\n      return millisecondsToSeconds(time);\n    },\n    set time(newTime) {\n      const timeInMs = secondsToMilliseconds(newTime);\n      if (holdTime !== null || !animationDriver) {\n        holdTime = timeInMs;\n      } else {\n        startTime = animationDriver.now() - timeInMs;\n      }\n    },\n    play,\n    pause: () => {\n      playState = \"paused\";\n      holdTime = time;\n    },\n    stop: () => {\n      onStop && onStop();\n      animationDriver && animationDriver.stop();\n      animationDriver = undefined;\n    },\n    sample: elapsed => {\n      startTime = 0;\n      return tick(elapsed);\n    }\n  };\n  return controls;\n}\nexport { animateValue };","map":{"version":3,"names":["keyframes","spring","inertia","frameloopDriver","interpolate","clamp","millisecondsToSeconds","secondsToMilliseconds","types","decay","tween","maxDuration","calculateDuration","generator","duration","timeStep","state","next","done","animateValue","_ref","autoplay","delay","driver","keyframes$1","type","repeat","repeatDelay","repeatType","onPlay","onStop","onComplete","onUpdate","options","resolveFinishedPromise","currentFinishedPromise","updateFinishedPromise","Promise","resolve","animationDriver","generatorFactory","mapNumbersToKeyframes","mirroredGenerator","reverse","velocity","playState","holdTime","startTime","calculatedDuration","resolvedDuration","Infinity","totalDuration","time","tick","timestamp","Math","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","iterationIsOdd","p","value","isAnimationFinished","finish","stop","play","now","start","controls","then","reject","newTime","timeInMs","pause","undefined","sample"],"sources":["E:/Desktop/reactpsc/node_modules/framer-motion/dist/es/animation/js/index.mjs"],"sourcesContent":["import { keyframes } from '../generators/keyframes.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { frameloopDriver } from './driver-frameloop.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\n\nconst types = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\nfunction calculateDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration;\n}\nfunction animateValue({ autoplay = true, delay = 0, driver = frameloopDriver, keyframes: keyframes$1, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", onPlay, onStop, onComplete, onUpdate, ...options }) {\n    let resolveFinishedPromise;\n    let currentFinishedPromise;\n    /**\n     * Create a new finished Promise every time we enter the\n     * finished state and resolve the old Promise. This is\n     * WAAPI-compatible behaviour.\n     */\n    const updateFinishedPromise = () => {\n        currentFinishedPromise = new Promise((resolve) => {\n            resolveFinishedPromise = resolve;\n        });\n    };\n    // Create the first finished promise\n    updateFinishedPromise();\n    let animationDriver;\n    const generatorFactory = types[type] || keyframes;\n    /**\n     * If this isn't the keyframes generator and we've been provided\n     * strings as keyframes, we need to interpolate these.\n     * TODO: Support velocity for units and complex value types/\n     */\n    let mapNumbersToKeyframes;\n    if (generatorFactory !== keyframes &&\n        typeof keyframes$1[0] !== \"number\") {\n        mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n            clamp: false,\n        });\n        keyframes$1 = [0, 100];\n    }\n    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n    let mirroredGenerator;\n    if (repeatType === \"mirror\") {\n        mirroredGenerator = generatorFactory({\n            ...options,\n            keyframes: [...keyframes$1].reverse(),\n            velocity: -(options.velocity || 0),\n        });\n    }\n    let playState = \"idle\";\n    let holdTime = null;\n    let startTime = null;\n    /**\n     * If duration is undefined and we have repeat options,\n     * we need to calculate a duration from the generator.\n     *\n     * We set it to the generator itself to cache the duration.\n     * Any timeline resolver will need to have already precalculated\n     * the duration by this step.\n     */\n    if (generator.calculatedDuration === null && repeat) {\n        generator.calculatedDuration = calculateDuration(generator);\n    }\n    const { calculatedDuration } = generator;\n    let resolvedDuration = Infinity;\n    let totalDuration = Infinity;\n    if (calculatedDuration) {\n        resolvedDuration = calculatedDuration + repeatDelay;\n        totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n    }\n    let time = 0;\n    const tick = (timestamp) => {\n        if (startTime === null)\n            return;\n        if (holdTime !== null) {\n            time = holdTime;\n        }\n        else {\n            time = timestamp - startTime;\n        }\n        // Rebase on delay\n        time = Math.max(time - delay, 0);\n        /**\n         * If this animation has finished, set the current time\n         * to the total duration.\n         */\n        if (playState === \"finished\" && holdTime === null) {\n            time = totalDuration;\n        }\n        let elapsed = time;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = time / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = currentIteration % 2;\n            if (iterationIsOdd) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            const p = time >= totalDuration\n                ? repeatType === \"reverse\" && iterationIsOdd\n                    ? 0\n                    : 1\n                : clamp(0, 1, iterationProgress);\n            elapsed = p * resolvedDuration;\n        }\n        const state = frameGenerator.next(elapsed);\n        let { value, done } = state;\n        if (onUpdate) {\n            onUpdate(mapNumbersToKeyframes ? mapNumbersToKeyframes(value) : value);\n        }\n        if (calculatedDuration !== null) {\n            done = time >= totalDuration;\n        }\n        const isAnimationFinished = holdTime === null &&\n            (playState === \"finished\" || (playState === \"running\" && done));\n        if (isAnimationFinished) {\n            finish();\n        }\n        return state;\n    };\n    const finish = () => {\n        animationDriver && animationDriver.stop();\n        playState = \"finished\";\n        onComplete && onComplete();\n        resolveFinishedPromise();\n        updateFinishedPromise();\n    };\n    const play = () => {\n        if (!animationDriver)\n            animationDriver = driver(tick);\n        const now = animationDriver.now();\n        onPlay && onPlay();\n        playState = \"running\";\n        if (holdTime !== null) {\n            startTime = now - holdTime;\n        }\n        else if (!startTime) {\n            // TODO When implementing play/pause, check WAAPI\n            // logic around finished animations\n            startTime = now;\n        }\n        holdTime = null;\n        animationDriver.start();\n    };\n    if (autoplay) {\n        play();\n    }\n    const controls = {\n        then(resolve, reject) {\n            return currentFinishedPromise.then(resolve, reject);\n        },\n        get time() {\n            return millisecondsToSeconds(time);\n        },\n        set time(newTime) {\n            const timeInMs = secondsToMilliseconds(newTime);\n            if (holdTime !== null || !animationDriver) {\n                holdTime = timeInMs;\n            }\n            else {\n                startTime = animationDriver.now() - timeInMs;\n            }\n        },\n        play,\n        pause: () => {\n            playState = \"paused\";\n            holdTime = time;\n        },\n        stop: () => {\n            onStop && onStop();\n            animationDriver && animationDriver.stop();\n            animationDriver = undefined;\n        },\n        sample: (elapsed) => {\n            startTime = 0;\n            return tick(elapsed);\n        },\n    };\n    return controls;\n}\n\nexport { animateValue };\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,6BAA6B;AACvD,SAASC,MAAM,QAAQ,gCAAgC;AACvD,SAASC,OAAO,QAAQ,2BAA2B;AACnD,SAASC,eAAe,QAAQ,wBAAwB;AACxD,SAASC,WAAW,QAAQ,6BAA6B;AACzD,SAASC,KAAK,QAAQ,uBAAuB;AAC7C,SAASC,qBAAqB,EAAEC,qBAAqB,QAAQ,iCAAiC;AAE9F,MAAMC,KAAK,GAAG;EACVC,KAAK,EAAEP,OAAO;EACdA,OAAO;EACPQ,KAAK,EAAEV,SAAS;EAChBA,SAAS,EAAEA,SAAS;EACpBC;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA,MAAMU,WAAW,GAAG,KAAK;AACzB,SAASC,iBAAiBA,CAACC,SAAS,EAAE;EAClC,IAAIC,QAAQ,GAAG,CAAC;EAChB,MAAMC,QAAQ,GAAG,EAAE;EACnB,IAAIC,KAAK,GAAGH,SAAS,CAACI,IAAI,CAACH,QAAQ,CAAC;EACpC,OAAO,CAACE,KAAK,CAACE,IAAI,IAAIJ,QAAQ,GAAGH,WAAW,EAAE;IAC1CG,QAAQ,IAAIC,QAAQ;IACpBC,KAAK,GAAGH,SAAS,CAACI,IAAI,CAACH,QAAQ,CAAC;EACpC;EACA,OAAOA,QAAQ;AACnB;AACA,SAASK,YAAYA,CAAAC,IAAA,EAA2M;EAAA,IAA1M;IAAEC,QAAQ,GAAG,IAAI;IAAEC,KAAK,GAAG,CAAC;IAAEC,MAAM,GAAGpB,eAAe;IAAEH,SAAS,EAAEwB,WAAW;IAAEC,IAAI,GAAG,WAAW;IAAEC,MAAM,GAAG,CAAC;IAAEC,WAAW,GAAG,CAAC;IAAEC,UAAU,GAAG,MAAM;IAAEC,MAAM;IAAEC,MAAM;IAAEC,UAAU;IAAEC,QAAQ;IAAE,GAAGC;EAAQ,CAAC,GAAAb,IAAA;EAC1N,IAAIc,sBAAsB;EAC1B,IAAIC,sBAAsB;EAC1B;AACJ;AACA;AACA;AACA;EACI,MAAMC,qBAAqB,GAAGA,CAAA,KAAM;IAChCD,sBAAsB,GAAG,IAAIE,OAAO,CAAEC,OAAO,IAAK;MAC9CJ,sBAAsB,GAAGI,OAAO;IACpC,CAAC,CAAC;EACN,CAAC;EACD;EACAF,qBAAqB,EAAE;EACvB,IAAIG,eAAe;EACnB,MAAMC,gBAAgB,GAAGhC,KAAK,CAACiB,IAAI,CAAC,IAAIzB,SAAS;EACjD;AACJ;AACA;AACA;AACA;EACI,IAAIyC,qBAAqB;EACzB,IAAID,gBAAgB,KAAKxC,SAAS,IAC9B,OAAOwB,WAAW,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;IACpCiB,qBAAqB,GAAGrC,WAAW,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,EAAEoB,WAAW,EAAE;MACvDnB,KAAK,EAAE;IACX,CAAC,CAAC;IACFmB,WAAW,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC;EAC1B;EACA,MAAMX,SAAS,GAAG2B,gBAAgB,CAAC;IAAE,GAAGP,OAAO;IAAEjC,SAAS,EAAEwB;EAAY,CAAC,CAAC;EAC1E,IAAIkB,iBAAiB;EACrB,IAAId,UAAU,KAAK,QAAQ,EAAE;IACzBc,iBAAiB,GAAGF,gBAAgB,CAAC;MACjC,GAAGP,OAAO;MACVjC,SAAS,EAAE,CAAC,GAAGwB,WAAW,CAAC,CAACmB,OAAO,EAAE;MACrCC,QAAQ,EAAE,EAAEX,OAAO,CAACW,QAAQ,IAAI,CAAC;IACrC,CAAC,CAAC;EACN;EACA,IAAIC,SAAS,GAAG,MAAM;EACtB,IAAIC,QAAQ,GAAG,IAAI;EACnB,IAAIC,SAAS,GAAG,IAAI;EACpB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIlC,SAAS,CAACmC,kBAAkB,KAAK,IAAI,IAAItB,MAAM,EAAE;IACjDb,SAAS,CAACmC,kBAAkB,GAAGpC,iBAAiB,CAACC,SAAS,CAAC;EAC/D;EACA,MAAM;IAAEmC;EAAmB,CAAC,GAAGnC,SAAS;EACxC,IAAIoC,gBAAgB,GAAGC,QAAQ;EAC/B,IAAIC,aAAa,GAAGD,QAAQ;EAC5B,IAAIF,kBAAkB,EAAE;IACpBC,gBAAgB,GAAGD,kBAAkB,GAAGrB,WAAW;IACnDwB,aAAa,GAAGF,gBAAgB,IAAIvB,MAAM,GAAG,CAAC,CAAC,GAAGC,WAAW;EACjE;EACA,IAAIyB,IAAI,GAAG,CAAC;EACZ,MAAMC,IAAI,GAAIC,SAAS,IAAK;IACxB,IAAIP,SAAS,KAAK,IAAI,EAClB;IACJ,IAAID,QAAQ,KAAK,IAAI,EAAE;MACnBM,IAAI,GAAGN,QAAQ;IACnB,CAAC,MACI;MACDM,IAAI,GAAGE,SAAS,GAAGP,SAAS;IAChC;IACA;IACAK,IAAI,GAAGG,IAAI,CAACC,GAAG,CAACJ,IAAI,GAAG9B,KAAK,EAAE,CAAC,CAAC;IAChC;AACR;AACA;AACA;IACQ,IAAIuB,SAAS,KAAK,UAAU,IAAIC,QAAQ,KAAK,IAAI,EAAE;MAC/CM,IAAI,GAAGD,aAAa;IACxB;IACA,IAAIM,OAAO,GAAGL,IAAI;IAClB,IAAIM,cAAc,GAAG7C,SAAS;IAC9B,IAAIa,MAAM,EAAE;MACR;AACZ;AACA;AACA;AACA;MACY,MAAMiC,QAAQ,GAAGP,IAAI,GAAGH,gBAAgB;MACxC;AACZ;AACA;AACA;MACY,IAAIW,gBAAgB,GAAGL,IAAI,CAACM,KAAK,CAACF,QAAQ,CAAC;MAC3C;AACZ;AACA;AACA;MACY,IAAIG,iBAAiB,GAAGH,QAAQ,GAAG,GAAG;MACtC;AACZ;AACA;AACA;MACY,IAAI,CAACG,iBAAiB,IAAIH,QAAQ,IAAI,CAAC,EAAE;QACrCG,iBAAiB,GAAG,CAAC;MACzB;MACAA,iBAAiB,KAAK,CAAC,IAAIF,gBAAgB,EAAE;MAC7C;AACZ;AACA;MACY,MAAMG,cAAc,GAAGH,gBAAgB,GAAG,CAAC;MAC3C,IAAIG,cAAc,EAAE;QAChB,IAAInC,UAAU,KAAK,SAAS,EAAE;UAC1BkC,iBAAiB,GAAG,CAAC,GAAGA,iBAAiB;UACzC,IAAInC,WAAW,EAAE;YACbmC,iBAAiB,IAAInC,WAAW,GAAGsB,gBAAgB;UACvD;QACJ,CAAC,MACI,IAAIrB,UAAU,KAAK,QAAQ,EAAE;UAC9B8B,cAAc,GAAGhB,iBAAiB;QACtC;MACJ;MACA,MAAMsB,CAAC,GAAGZ,IAAI,IAAID,aAAa,GACzBvB,UAAU,KAAK,SAAS,IAAImC,cAAc,GACtC,CAAC,GACD,CAAC,GACL1D,KAAK,CAAC,CAAC,EAAE,CAAC,EAAEyD,iBAAiB,CAAC;MACpCL,OAAO,GAAGO,CAAC,GAAGf,gBAAgB;IAClC;IACA,MAAMjC,KAAK,GAAG0C,cAAc,CAACzC,IAAI,CAACwC,OAAO,CAAC;IAC1C,IAAI;MAAEQ,KAAK;MAAE/C;IAAK,CAAC,GAAGF,KAAK;IAC3B,IAAIgB,QAAQ,EAAE;MACVA,QAAQ,CAACS,qBAAqB,GAAGA,qBAAqB,CAACwB,KAAK,CAAC,GAAGA,KAAK,CAAC;IAC1E;IACA,IAAIjB,kBAAkB,KAAK,IAAI,EAAE;MAC7B9B,IAAI,GAAGkC,IAAI,IAAID,aAAa;IAChC;IACA,MAAMe,mBAAmB,GAAGpB,QAAQ,KAAK,IAAI,KACxCD,SAAS,KAAK,UAAU,IAAKA,SAAS,KAAK,SAAS,IAAI3B,IAAK,CAAC;IACnE,IAAIgD,mBAAmB,EAAE;MACrBC,MAAM,EAAE;IACZ;IACA,OAAOnD,KAAK;EAChB,CAAC;EACD,MAAMmD,MAAM,GAAGA,CAAA,KAAM;IACjB5B,eAAe,IAAIA,eAAe,CAAC6B,IAAI,EAAE;IACzCvB,SAAS,GAAG,UAAU;IACtBd,UAAU,IAAIA,UAAU,EAAE;IAC1BG,sBAAsB,EAAE;IACxBE,qBAAqB,EAAE;EAC3B,CAAC;EACD,MAAMiC,IAAI,GAAGA,CAAA,KAAM;IACf,IAAI,CAAC9B,eAAe,EAChBA,eAAe,GAAGhB,MAAM,CAAC8B,IAAI,CAAC;IAClC,MAAMiB,GAAG,GAAG/B,eAAe,CAAC+B,GAAG,EAAE;IACjCzC,MAAM,IAAIA,MAAM,EAAE;IAClBgB,SAAS,GAAG,SAAS;IACrB,IAAIC,QAAQ,KAAK,IAAI,EAAE;MACnBC,SAAS,GAAGuB,GAAG,GAAGxB,QAAQ;IAC9B,CAAC,MACI,IAAI,CAACC,SAAS,EAAE;MACjB;MACA;MACAA,SAAS,GAAGuB,GAAG;IACnB;IACAxB,QAAQ,GAAG,IAAI;IACfP,eAAe,CAACgC,KAAK,EAAE;EAC3B,CAAC;EACD,IAAIlD,QAAQ,EAAE;IACVgD,IAAI,EAAE;EACV;EACA,MAAMG,QAAQ,GAAG;IACbC,IAAIA,CAACnC,OAAO,EAAEoC,MAAM,EAAE;MAClB,OAAOvC,sBAAsB,CAACsC,IAAI,CAACnC,OAAO,EAAEoC,MAAM,CAAC;IACvD,CAAC;IACD,IAAItB,IAAIA,CAAA,EAAG;MACP,OAAO9C,qBAAqB,CAAC8C,IAAI,CAAC;IACtC,CAAC;IACD,IAAIA,IAAIA,CAACuB,OAAO,EAAE;MACd,MAAMC,QAAQ,GAAGrE,qBAAqB,CAACoE,OAAO,CAAC;MAC/C,IAAI7B,QAAQ,KAAK,IAAI,IAAI,CAACP,eAAe,EAAE;QACvCO,QAAQ,GAAG8B,QAAQ;MACvB,CAAC,MACI;QACD7B,SAAS,GAAGR,eAAe,CAAC+B,GAAG,EAAE,GAAGM,QAAQ;MAChD;IACJ,CAAC;IACDP,IAAI;IACJQ,KAAK,EAAEA,CAAA,KAAM;MACThC,SAAS,GAAG,QAAQ;MACpBC,QAAQ,GAAGM,IAAI;IACnB,CAAC;IACDgB,IAAI,EAAEA,CAAA,KAAM;MACRtC,MAAM,IAAIA,MAAM,EAAE;MAClBS,eAAe,IAAIA,eAAe,CAAC6B,IAAI,EAAE;MACzC7B,eAAe,GAAGuC,SAAS;IAC/B,CAAC;IACDC,MAAM,EAAGtB,OAAO,IAAK;MACjBV,SAAS,GAAG,CAAC;MACb,OAAOM,IAAI,CAACI,OAAO,CAAC;IACxB;EACJ,CAAC;EACD,OAAOe,QAAQ;AACnB;AAEA,SAASrD,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}